#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : require

#include "random.glsl"
#include "common.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT TLAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform UBO
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 viewPos;
    vec3 lightPos;
    uint frame;
} ubo;

layout(location = 0) rayPayloadEXT Payload pld;

void main()
{
    pld.rngState = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, ubo.frame);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);

    // multiply view inverse to get camera's world position
    vec4 origin = ubo.viewInverse * vec4(0, 0, 0, 1);

    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 totalColor = vec3(0);

    const int samples = 8;
    const int traces = 4;

    // Trace multiple rays for e.g. transparency
    for (int smpl = 0; smpl < samples; smpl++) {
        const vec2 randomOffset = 0.375 * randomGaussian(pld.rngState);
        const vec2 randomPixelCenter = pixelCenter + randomOffset;

        // transform coords to (-1, 1) x (-1, 1)
        const vec2 inUV = randomPixelCenter / vec2(gl_LaunchSizeEXT.xy);
        const vec2 d = inUV * 2.0 - 1.0;

        // multiply view inverse and proj inverse to get target's
        // world position
        const vec4 target = ubo.projInverse * vec4(d.x, d.y, 1, 1);
        const vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0.0);

        vec3 rayOrigin = origin.xyz;
        vec3 rayDirection = direction.xyz;
        vec3 accumulatedColor = vec3(1.0);

        for (int trace = 0; trace < traces; trace++) {
            traceRayEXT(
                TLAS, // top level acceleration structure
                gl_RayFlagsNoneEXT, // ray flags (gl_RayFlagsOpaqueEXT)
                0xff, // cull mask (hit if cull mask & instance.mask != 0)
                0, // sbtRecordOffset
                0, // sbtRecordStride
                0, // missIndex (index of shaders in miss group to call when not hit)
                rayOrigin, // ray origin
                tmin, // ray min range
                rayDirection, // ray direction
                tmax, // ray max range
                0 // payload location
            );
            accumulatedColor *= pld.color;
            if (pld.miss) {
                // totalColor += accumulatedColor;
                break;
            } else {
                rayOrigin = pld.newOrigin;
                rayDirection = pld.newDirection;
            }
        }
        totalColor += accumulatedColor;
    }

    vec3 averageColor = totalColor / float(samples);
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(averageColor, 1.0f));
}
